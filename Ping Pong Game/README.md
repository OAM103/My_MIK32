
# Арканоид на MIK32
![photo_2025-10-24_11-22-09](https://github.com/user-attachments/assets/641a41a3-b69f-41cb-8bd2-c4fa5d5e39a1)

##  Описание проекта

Этот проект представляет собой реализацию классической игры «Арканоид», написанную на C для микроконтроллера MIK32V2.
Игра отображается на SPI-дисплее и полностью работает в реальном времени без операционной системы.

Игрок управляет платформой, отражающей мяч, который разбивает кирпичи.
Цель — уничтожить все препятствия, не дав шару упасть за нижнюю границу экрана.

---

##  Аппаратная часть

Используемые компоненты:

* MIK32V2 — 32-битный RISC-V микроконтроллер (16 КБ RAM, 4 МБ Flash)
* SPI-дисплей (цветной TFT)
* Питание 3.3 В

---

## Особенности работы с MIK32

Работа с этим микроконтроллером требует внимания к ряду нюансов:

1. Ограничение по памяти:

   * RAM всего 16 КБ, поэтому нельзя хранить кадровый буфер для экрана.
   * Все графические элементы (мяч, кирпичи, платформа) отрисовываются *прямо в SPI* — “на лету”.

2. SPI без DMA:

   * Для стабильной работы дисплея используется *прямое управление SPI-регистрами*.
   * Применяются ручные вызовы Lcd_select() / Lcd_unselect() и контроль флагов FIFO.

3. Управление RS/DC:

   * Переход между командами и пиксельными данными выполняется вручную:

    
     HAL_GPIO_WritePin(GPIO_0, RS, 0); // Команда
     HAL_GPIO_WritePin(GPIO_0, RS, 1); // Данные
     
4. Отрисовка примитивов:

   * Реализованы функции:

     * H_line() и V_line() — горизонтальные и вертикальные линии
     * rect() — прямоугольники
     * drawCircle() — круги (мяч)
     * trapezoid() — универсальные трапеции (препятствия)

5. Минимизация нагрузки на SPI:

   * Экран перерисовывается только частично:
     при движении мяча и платформы очищаются лишь нужные участки (clearBall()), а не весь экран.

---

## Архитектура игры

main.c
├── init_display()   // инициализация SPI и дисплея
├── draw_game()      // отрисовка элементов уровня
├── update_ball()    // физика движения шара
├── check_collisions() // обработка столкновений с кирпичами и стенами
└── render_result()  // экраны победы и проигрыша
ball.c — логика движения и столкновений шара
brick.c — массив кирпичей и их визуализация
lcd.c — низкоуровневые функции отрисовки через SPI

---

## Геймплей

| Экран игры                               | Победа                                  | Проигрыш                                 |
| ---------------------------------------- | --------------------------------------- | ---------------------------------------- |
|![photo_2025-10-24_11-22-09](https://github.com/user-attachments/assets/926603c8-84b8-48b2-b5bf-7e9f1dac2253) | ![photo_2025-10-24_11-22-06](https://github.com/user-attachments/assets/ce98ac56-37b2-409c-a63f-d9dd21fdd117)
 | ![photo_2025-10-24_11-22-12](https://github.com/user-attachments/assets/0abd60d9-628a-437e-817c-7a788c16df85)
 |

---

##  Управление

* движение платформы c помощью tauchpad на ограниченной прямоугольной области
* начало игры
* После окончания можно перезапустить для новой попытки

---

## Особенности реализации

* Все координаты мяча обрабатываются в формате float для плавной физики.
* Столкновения с кирпичами реализованы через проверку границ прямоугольников.
* При уничтожении всех кирпичей отображается экран победы.
* При падении шара ниже платформы — экран проигрыша.

---

## Возможные доработки

* Добавить уровни с разным расположением препятствий.
* Оптимизировать SPI через DMA при достаточной памяти.
* Реализовать систему очков.

---

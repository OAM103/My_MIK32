# Touchpad & Joystick 3D — Управление и псевдо-3D на маленьком экране

Кратко: проект реализует масштабирование и вращение прямоугольника (тачпадом), псевдо‑3D отображение на экране и поворот 3D‑куба как с тачпада, так и с джойстика. В README — подробное объяснение архитектуры, алгоритмов, схема подключения, инструкции по сборке и примеры кода. В папке docs/images/ положите 5 фото (см. раздел "Фотографии").

---

## Содержание

1. [Обзор](#обзор)
2. [Функциональность](#функциональность)
3. [Аппаратная часть](#аппаратная-часть)
4. [Программная архитектура](#программная-архитектура)
5. [Алгоритмы и реализация](#алгоритмы-и-реализация)

   * масштабирование (тачпад)
   * вращение (тачпад)
   * псевдо‑3D (проекция)
   * вращение куба (тачпад и джойстик)
   * фильтрация и калибровка джойстика
6. [Как собрать и прошить](#как-собрать-и-прошить)
7. [Как пользоваться — UI/контролы](#как-пользоваться)
8. [Фотографии](#фотографии)
9. [Отладка и советы](#отладка-и-советы)
10. [Лицензия и вклад](#лицензия-и-вклад)

---

## Обзор

Цель проекта — получить удобный интерфейс управления графическим объектом (прямоугольник и куб) на микроконтроллере с экраном и двумя входами управления:

* тачпад — мультитач/жесты для масштабирования и вращения прямоугольника; для куба тачпад даёт скорость/направление вращения;
* джойстик — обеспечивает физическое управление поворотом куба; реализованы фильтрация, мёртвая зона и возможность калибровки центра;
* псевдо‑3D — отрисовка куба с перспективой (проекция) и видимыми гранями.

Проект предназначен как демо для обучения и как модуль для интеграции в более крупные интерфейсы.

---

## Функциональность

* Масштабирование прямоугольника жестом «pinch» (двумя пальцами) — плавное изменение масштаба.
* Вращение прямоугольника жестом поворота двух пальцев (rotation gesture).
* Псевдо‑3D на экране: проекция 3D точек на 2D с управлением перспективой.
* Вращение 3D‑куба:

  * с тачпада — поворот пока пользователь держит жест/свайп; скорость зависит от величины жеста;
  * с джойстика — интегральное (накапливаемое) вращение: при отклонении джойстика куб вращается непрерывно; при отпускании — куб остаётся на месте; при нажатии кнопки — сброс в исходное положение.
* Фильтрация входных данных (скользящее среднее), мёртвая зона и автокалибровка центра.

---

## Аппаратная часть

Минимальный набор:

* MCU (STM32 семейства, на котором работает HAL и SPI)
* Дисплей (совместимый с вашей графической библиотекой)
* Тачпад (I2C/USB/PS/2 — реализован драйвер жестов в проекте)
* Джойстик с кнопкой (SPI/ADC или модуль с цифровым интерфейсом)
* Провода, питание, отладчик

Подключение джойстика (пример для SPI-джойстика):

* hspi1 — шина SPI, подключенная к джойстику
* GPIO_CS — пин CS
* master_output_ch6, master_output_ch7, master_input_x, master_input_y — буферы/команды обмена

(Если у тебя другой интерфейс — ADC/analog joystick или I2C — в разделе "Отладка" есть подсказки.)

---

## Программная архитектура

Проект разделён на слои:

1. HAL / драйверы: чтение тачпада, джойстика, управление SPI/I2C, обработка прерываний.
2. Input layer: фильтрация, детектирование жестов, калибровка центра джойстика, dead‑zone.
3. Controller / Logic: перевод входов в угловые скорости/масштаб и управление состоянием сцены.
4. Renderer: преобразование 3D → 2D (матрицы трансформации), отрисовка прямоугольника и куба на экран.

---

## Алгоритмы и реализация

### Масштабирование прямоугольника (тачпад)

Идея: при мультитач-событии вычисляем расстояние между двумя пальцами d = ||p1 - p2||. Относительное изменение d переводим в коэффициент масштаба s.

Формула:

scale_new = scale_prev * (d_current / d_start)
Где d_start — расстояние при начале жеста, d_current — текущее. Рекомендации:

* Ограничь scale диапазоном, например [0.2, 4.0].
* Применяй сглаживание (low-pass) к scale чтобы избежать рывков.

Псевдокод:
if (gesture == PINCH_START) {
    pinch_start_dist = distance(p1, p2);
    scale_start = scale;
}
if (gesture == PINCH_MOVE) {
    float factor = distance(p1, p2) / pinch_start_dist;
    scale = clamp(scale_start * factor, MIN_SCALE, MAX_SCALE);
}
---

### Вращение прямоугольника (тачпад)

Идея: угол между вектором p2 - p1 в начальный момент и текущий даёт изменение угла delta_angle.

angle_new = angle_start + (angle_current - angle_start)
Плавность достигается низкочастотной фильтрацией и ограничением скорости.

---

### Псевдо‑3D (проекция)

Для псевдо‑3D используется простая перспективая проекция точки (x, y, z) в экранные координаты (X, Y):

float fov = focal_distance; // например 200.0f
X = (x * fov) / (z + z_offset) + screen_cx;
Y = (y * fov) / (z + z_offset) + screen_cy;
Рекомендуется хранить вершины куба в локальной системе координат, применять к ним матрицы вращения Rx, Ry, Rz, затем переводить в мировые координаты, смещать в z‑ось и проецировать.

---

### Вращение куба (тачпад и джойстик)

Тачпад: при движении пальца вычисляем dx, dy — и переводим в угловые скорости:

angle_x += dy * TOUCH_SENSITIVITY;
angle_y += dx * TOUCH_SENSITIVITY;
Движение применяется только пока жест активен; при отпускании — вращение прекращается, но углы сохраняются.

Джойстик: используем подход, который мы обсуждали и отладили:

* Берём avgX, avgY — после фильтра скользящего среднего.
* Вычитаем центр (калиброванный) → dX = avgX - centerX, dY = avgY - centerY.
* Применяем мёртвую зону: если abs(dX) < DEAD_ZONE → dX = 0.
* Интегрируем скорость в углы (накапливаем):

if (dX != 0 || dY != 0) {
    angle_x += (float)dY * JOY_GAIN;
    angle_y += (float)dX * JOY_GAIN;
}
* Кнопка джойстика — reset (angle_x = angle_y = 0).
* Рекомендуем добавить калибровку при старте: несколько секунд считывать среднее как centerX, centerY.

Пример конфигов:

#define FILTER_SIZE 8
#define DEAD_ZONE 30           // подбери экспериментально
#define JOY_GAIN 0.001f
---

### Фильтрация и калибровка джойстика

Фильтр: скользящее среднее по FILTER_SIZE с последующим вычислением avgX/avgY. Это снижает шум и исключает мелкие скачки.

Калибровка центра (простейшая): при включении зажать джойстик в нейтрали на 2–3 с — запомнить centerX = avgX, centerY = avgY.

---

## Как собрать и прошить

1. Открой проект в STM32CubeIDE (или свою среду).
2. Установи настройки hspi1, пины CS в MX_GPIO_Init и тайминги SPI.
3. Скомпилируй и прошей плату через ST‑Link.

Запуск: подключи питание и открой монитор (UART) для логов. В логе будут строки вроде Joystick: dX=..., dY=... для отладки.

---

## Как пользоваться

* Масштабирование прямоугольника: помести два пальца и раздвинь/сожми.
* Вращение прямоугольника: поворачивай два пальца как при прокрутке изображения.
* Поворот куба (тачпад): свайпни по экрану — куб меняет угол, пока двигаешь.
* Поворот куба (джойстик): отклони джойстик — куб начнёт крутиться; отпусти — куб остановится; нажми кнопку — куб сбросится в ноль.

---

## Фотографии

Положи 5 фото в docs/images/ с такими именами и подписью в README:

![Сборка (вид сверху)](docs/images/01_assembly_top.jpg)
*Сборка (вид сверху) — показаны дисплей, тачпад, джойстик*.

![Тачпад масштабирование](docs/images/02_touchpad_pinch.jpg)
*Масштабирование прямоугольника жестом pinch.*

![Тачпад вращение](docs/images/03_touchpad_rotate.jpg)
*Вращение прямоугольника жестом.*

![Псевдо-3D и куб](docs/images/04_cube_perspective.jpg)
*Псевдо‑3D — куб в перспективе.*

![Джойстик управление](docs/images/05_joystick.jpg)
*Управление кубом с помощью джойстика (и кнопка reset).* 
Если у тебя другие имена файлов — просто поправь пути в README.

---

## Отладка и советы
* Куб «сам двигается»: увеличь DEAD_ZONE или увеличь FILTER_SIZE для сильной фильтрации; обязательно пройдись автокалибровкой центра.
* Рывки при жестах: добавь low‑pass фильтр (экспоненциальное сглаживание) для scale и angle.
* Производительность: рисование линий/полигонов может быть тяжёлым; реализуй двойную буферизацию или уменьшай разрешение при анимации.

---

## Лицензия и вклад

Рекомендую MIT License для простоты. Добавь LICENSE в корень репозитория.

Если хочешь — я могу подготовить LICENSE файл и CONTRIBUTING.md.

---

## Контакт и дальнейшие шаги

Если нужно — могу:

* адаптировать README под английский;
* сгенерировать CHANGELOG и RELEASE шаблон;
* подготовить STM32CubeIDE проектную структуру и пример Makefile;
* вставить реальные фото прямо в README (пришли файлы или их имена).

---

Спасибо за подробный бриф — положи, пожалуйста, в docs/images/ свои 5 фото с предложенными именами и я обновлю README, чтобы картинки отображались прямо в файле.
